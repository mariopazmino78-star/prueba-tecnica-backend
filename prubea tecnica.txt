Prueba Técnica – Backend Developer (Reto 1 y 2) (2 dias) 
Stack: FastAPI · MongoDB · RabbitMQ · Railway 
Reto 1: CRUD de Usuarios (FastAPI + MongoDB) 
Objetivo: 
Evaluar la capacidad para crear una API REST completa, asíncrona y tipada, con 
validaciones y conexión a MongoDB. 
Instrucciones 
1. Crear un microservicio `user_service` con los endpoints: - POST /users/ → Crear usuario (campos: name, email, password). Encriptar contraseña 
con bcrypt. - GET /users/{id} → Obtener usuario por ID. - PUT /users/{id} → Actualizar usuario. - DELETE /users/{id} → Eliminar usuario. 
2. Usar Pydantic para validaciones y respuesta. 
3. Implementar un middleware que registre tiempo de respuesta y guarde logs en consola. 
4. Documentar endpoints en /docs (Swagger). 
Entregables - Carpeta `user_service/` con: - main.py - models/user.py - routes/user_routes.py - config/database.py - Dockerfile - requirements.txt - .env.example - README.md - El README.md debe incluir: - Cómo crear la BD y colección. - Comando para levantar en local. - Ejemplo JSON de creación de usuario. - Ejemplo de prueba con curl o Postman. 
Evaluación - Correcto uso de FastAPI y MongoDB async. - Encriptación con bcrypt. - Validaciones y manejo de errores. - Documentación y claridad de código. - Ejecución funcional local + Railway. 
Tiempo sugerido: 1 Dia. 
Reto 2: Comunicación entre microservicios (RabbitMQ) 
Objetivo: 
Evaluar el diseño de microservicios desacoplados con colas de mensajería. 
Instrucciones 
1. Crear dos microservicios: - orders_service → Crea pedidos. - notifications_service → Escucha mensajes de RabbitMQ. 
2. Cuando se ejecuta POST /orders: - Guarda el pedido en MongoDB. - Publica un mensaje en la cola orders_queue. 
3. notifications_service escucha la cola y muestra en consola: 
"New order received: {order_id}". 
Entregables - Carpeta raíz con dos servicios: - /orders_service/ - main.py, routes/orders.py, config/rabbit.py, Dockerfile - /notifications_service/ - consumer.py, config/rabbit.py, Dockerfile - docker-compose.yml (opcional, pero valorado) que levante ambos servicios y RabbitMQ 
local. - .env.example con MONGODB_URI y RABBITMQ_URL. - README.md con: - Cómo levantar RabbitMQ en local. - Cómo probar el flujo (crear pedido → recibir mensaje). 
Evaluación - Correcta integración con RabbitMQ. - Diseño asíncrono y manejo de errores. - Claridad de logs. - Despliegue funcional en Railway (servicios independientes). 
Tiempo sugerido: 1 Dia.